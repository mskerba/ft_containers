#include "vector.hpp"


/***********************************************/
/*                default constructor          */
/***********************************************/


template<typename T, typename A>
ft::vector<T, A>::vector (const allocator_type& alloc) :__container(nullptr), __size(0), __capacity(0), __alloc(alloc){}



/***********************************************/
/*                fill constructor             */
/***********************************************/



template<typename T, typename A>
ft::vector<T, A>::vector (size_type n, const value_type& val, const allocator_type& alloc): __size(n), __capacity(n), __alloc(alloc)
{
    if (!n)
        return ;
    __container = __alloc.allocate(n);
    for(size_type i = 0; i < __size; i++)
        __alloc.construct(&__container[i], val);
}



/***********************************************/
/*               range constructor             */
/***********************************************/


template<typename T, typename A>
template <class InputIterator> 
ft::vector<T, A>::vector (InputIterator first, InputIterator last, const allocator_type& alloc): __size(last - first), __capacity(__size), __alloc(alloc)
{
    if (size() < 0)
        throw  std::length_error("vector");
    this->__container = __alloc.allocate(this->__size);
    size_type i = -1;
    while (first != last)
        __alloc.construct(&__container[++i], *(first++));
}


/***********************************************/
/*               copy constructor              */
/***********************************************/


template<typename T, typename A>
ft::vector<T, A>::vector(const vector& x): __size(x.__size), __capacity(x.__capacity)
{
    if (!size()) return ;
    this->__container = __alloc.allocate(this->__size);
    for(size_type i = 0; i < this->__size; i++)
        __alloc.construct(&__container[i], x.__container[i]);
}


/***********************************************/
/*                 destructor                  */
/***********************************************/

template<typename T, typename A>
ft::vector<T, A>::~vector()
{
    this->destroyed();
    this->__size = 0;
    this->__capacity = 0;
}


/***********************************************/
/*                 operator=                   */
/***********************************************/

template<typename T, typename A>
ft::vector<T, A>& ft::vector<T, A>::operator= (const ft::vector<T, A>& x)
{
    if(this->size() < x.size())
    {
        this->destroyed();
        this->__container = __alloc.allocate(x.size());
        for (size_t i = 0; i < x.size(); i++)
            __alloc.construct(&__container[i], x.__container[i]);
        this->__size = x.size();
        this->__capacity = x.__capacity;
        return (*this);
    }
    for (size_t i = 0; i < x.size(); i++)
        this->__container[i] = x.__container[i];
    for (size_t i = this->size(); i > x.size() ; i--)
        __alloc.destroy(&this->__container[i - 1]);
    this->__size = x.size();
    return (*this);
}

/***********************************************/
/*                   size                      */
/***********************************************/

template<typename T, typename A>
typename ft::vector<T, A>::size_type ft::vector<T, A>::size() const
{
    return (this->__size);
}


/***********************************************/
/*                 max_size                    */
/***********************************************/

template<typename T, typename A>
size_t ft::vector<T, A>::max_size() const
{
    int sizeT = sizeof(T);
    if (sizeT == 1)
        sizeT = 2;
    return (std::numeric_limits<std::size_t>::max() / sizeT);
}

/***********************************************/
/*                   resize                    */
/***********************************************/

template<typename T, typename A>
void ft::vector<T, A>::resize (size_type n, value_type val)
{
    if (n < this->__size)
    {
        for (size_type i = this->__size; i > n; i--)
            this->__alloc.destroy(&__container[i - 1]);
        __size = n;
        return ;
    }
    else if (n < this->capacity())
    {
        for (size_type i = n; i > this->size(); i--)
            __alloc.construct(&__container[i - 1], val);
        this->__size = n;
        return ;
    }
    else if (n > this->capacity())
    {
        pointer newcontainer  = __alloc.allocate(n);
        for (size_type i = this->__size; i < n; i++)
            __alloc.construct(&newcontainer[i], val);

        for (size_type i = this->__size; i > 0; i--)
             __alloc.construct(&newcontainer[i - 1], this->__container[i - 1]);
        this->destroyed();
        __container = newcontainer;
    }
    this->__size = n;
    if (n > this->__capacity && n < 2 * this->__capacity)
        n *= 2;
    this->__capacity = n;
}

/***********************************************/
/*                 capacity                    */
/***********************************************/

template<typename T, typename A>
size_t ft::vector<T, A>::capacity () const
{
    return (this->__capacity);
}

/***********************************************/
/*                   empty                     */
/***********************************************/

template<typename T, typename A>
bool ft::vector<T, A>::empty() const
{
    if (this->__size)
        return (false);
    return (true);
}

/***********************************************/
/*                 reserve                     */
/***********************************************/

template<typename T, typename A>
void ft::vector<T, A>::reserve (size_type n)
{
    if (n <= this->__capacity)
        return ;
    pointer newcontainer;
    newcontainer = __alloc.allocate(n);
    for (size_type i = this->__size; i > 0; i--)
        __alloc.construct(&newcontainer[i - 1], this->__container[i - 1]);
    this->destroyed();
    __container = newcontainer;
    __capacity = n;
}

/***********************************************/
/*                shrink_to_fit                */
/***********************************************/

template<typename T, typename A>
void ft::vector<T, A>::shrink_to_fit()
{
    pointer newcontainer;
    newcontainer = __alloc.allocate(__size);
    for (size_type i = this->__size - 1;; i--)
    {
        __alloc.construct(&newcontainer[i], this->__container[i]);
        if (!i) break;
    }
    for (size_type i = this->__size - 1;; i--)
    {
        __alloc.destroy(&this->__container[i]);
        if (!i) break;
    }
    __container = newcontainer;
    __capacity = __size;
}

/***********************************************/
/*                  operator[]                 */
/***********************************************/

template<typename T, typename A>
T& ft::vector<T, A>::operator[] (size_t n)
{
    return (this->__container[n]);
}

template<typename T, typename A>
const T& ft::vector<T, A>::operator[] (size_t n) const
{
    return (this->__container[n]);
}

/***********************************************/
/*                      at                     */
/***********************************************/

template<typename T, typename A>
T& ft::vector<T, A>::at (size_t n)
{
    if (n >= this->size())
        throw std::out_of_range("vector");
    return (this->__container[n]);
}

template<typename T, typename A>
const T& ft::vector<T, A>::at (size_t n) const
{
    if (n >= this->size())
        throw std::out_of_range("vector");
    return (this->__container[n]);
}

/***********************************************/
/*                    front                    */
/***********************************************/

template<typename T, typename A>
T& ft::vector<T, A>::front()
{
    return (this->__container[0]);
}

template<typename T, typename A>
const T& ft::vector<T, A>::front() const
{
    return (this->__container[0]);
}

/***********************************************/
/*                    back                    */
/***********************************************/

template<typename T, typename A>
T& ft::vector<T, A>::back()
{
    return (this->__container[__size - 1]);
}

template<typename T, typename A>
const T& ft::vector<T, A>::back() const
{
    return (this->__container[__size - 1]);
}

/***********************************************/
/*                    data                     */
/***********************************************/

template<typename T, typename A>
T* ft::vector<T, A>::data() throw()
{
    return (__container);
}

template<typename T, typename A>
const T* ft::vector<T, A>::data() const throw()
{
    return (__container);
}

/***********************************************/
/*                 assigner                    */
/***********************************************/

template<typename T, typename A>
template <class InputIterator>
void ft::vector<T, A>::assign (InputIterator first, InputIterator last)
{
    if (first > last)
    {
        this->~vector();
        throw std::length_error("vector");
    }
    for (size_type i = this->__size;i; i--)
        __alloc.destroy(&this->__container[i - 1]);
    this->__size = last - first;
    this->__container = this->__alloc.allocate(this->__size);
    size_type i = -1;
    while (first != last)
        __alloc.construct(&__container[++i], *(first++));
    this->__capacity = this->__size;
}

template<typename T, typename A>
void ft::vector<T, A>::assign (size_type n, const value_type& val)
{
    for (size_type i = this->__size; i; i--)
        __alloc.destroy(&this->__container[i - 1]);
    this->__container = this->__alloc.allocate(n);
    this->__size = n;
    if (capacity() < n)
        this->__capacity = n;
    for(size_type i = 0; i < __size; i++)
        __alloc.construct(&__container[i], val);
}

/***********************************************/
/*                  push_back                  */
/***********************************************/

template<typename T, typename A>
void ft::vector<T, A>::push_back (const value_type& val)
{
    if (__capacity && __capacity - __size)
    {
        this->__alloc.construct(&__container[__size++], val);
        return ;
    }
    __capacity *= 2;
    if (!(__capacity)) __capacity = 1;
    pointer newcontainer;
    newcontainer = __alloc.allocate(__capacity);
    __alloc.construct(&newcontainer[__size], val);
    for (size_type i = this->__size; i; i--)
        __alloc.construct(&newcontainer[i - 1], this->__container[i - 1]);
    this->destroyed();
    __size++;
    __container = newcontainer;
}

/***********************************************/
/*                 pop_back                    */
/***********************************************/

template<typename T, typename A>
void ft::vector<T, A>::pop_back ()
{
    this->__size--;
    __alloc.destroy(&__container[__size]);
}

// !/***********************************************/
// !/*                  insert                     */
// !/***********************************************/

// ! template<typename T, typename A>
// ! iterator ft::vector<T, A>::insert (iterator position, const value_type& val)
// ! {
// ! 
// ! }
// ! 
// ! template<typename T, typename A>
// ! void ft::vector<T, A>::insert (iterator position, size_type n, const value_type& val)
// ! {
// ! 
// ! }
// ! 
// ! template<typename T, typename A>
// ! template <class InputIterator>
// ! void ft::vector<T, A>::insert (iterator position, InputIterator first, InputIterator last)
// ! {
// ! 
// ! }

// !/***********************************************/
// !/*                  insert                     */
// !/***********************************************/

// ! template<typename T, typename A>
// ! iterator ft::vector<T, A>::erase (iterator position)
// ! {
// ! 
// ! }
// ! 
// ! template<typename T, typename A>
// ! iterator ft::vector<T, A>::erase (iterator first, iterator last)
// ! {
// ! 
// ! }

/***********************************************/
/*                   swap                      */
/***********************************************/

template<typename T, typename A>
void ft::vector<T, A>::swap (ft::vector<T, A>& x)
{
    std::swap(this->__container, x.__container);
    std::swap(this->__size, x.__size);
    std::swap(this->__capacity, x.__capacity);
}

/***********************************************/
/*                  clear                     */
/***********************************************/

template<typename T, typename A>
void ft::vector<T, A>::clear ()
{
    while (1)
    {
        if (!size()) break;
        __alloc.destroy(&this->__container[--(__size)]);
    }
}

/***********************************************/
/*                get_allocator                */
/***********************************************/

template<typename T, typename A>
typename ft::vector<T, A>::allocator_type ft::vector<T, A>::get_allocator() const
{
    return (this->__alloc);
}

/***********************************************/
/*                  iterator                   */
/***********************************************/

template<typename T, typename A>
ft::vector<T, A>::iterator::iterator (){}

template<typename T, typename A>
ft::vector<T, A>::iterator::iterator (pointer p): ptr(p){}

template<typename T, typename A>
ft::vector<T, A>::iterator::iterator (const iterator& x):ptr(x.ptr){}

template<typename T, typename A>
typename ft::vector<T, A>::iterator& ft::vector<T, A>::iterator::operator= (const iterator& x)
{
    this->ptr = x.ptr;
    return (*this);
}

template<typename T, typename A>
bool    ft::vector<T, A>::iterator::operator== (const iterator& x) const
{
    if (this->ptr == x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
bool    ft::vector<T, A>::iterator::operator!= (const iterator& x) const
{
    if (this->ptr != x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
bool    ft::vector<T, A>::iterator::operator>= (const iterator& x) const
{
    if (this->ptr >= x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
bool    ft::vector<T, A>::iterator::operator<= (const iterator& x) const
{
    if (this->ptr <= x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
bool    ft::vector<T, A>::iterator::operator< (const iterator& x) const
{
    if (this->ptr < x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
bool    ft::vector<T, A>::iterator::operator> (const iterator& x) const
{
    if (this->ptr > x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
typename ft::vector<T, A>::reference ft::vector<T, A>::iterator::operator* () const
{
    return (*ptr);
}

template<typename T, typename A>
typename ft::vector<T, A>::pointer ft::vector<T, A>::iterator::operator-> () const
{
    return (ptr);
}

template<typename T, typename A>
typename ft::vector<T, A>::iterator& ft::vector<T, A>::iterator::operator++ ()
{
    ++ptr;
    return (*this);
}

template<typename T, typename A>
typename ft::vector<T, A>::iterator& ft::vector<T, A>::iterator::operator-- ()
{
    --ptr;
    return (*this);
}

template<typename T, typename A>
typename ft::vector<T, A>::iterator ft::vector<T, A>::iterator::operator++ (int)
{
    iterator tmp =(*this);

    ++(ptr);
    return (tmp);
}

template<typename T, typename A>
typename ft::vector<T, A>::iterator ft::vector<T, A>::iterator::operator-- (int)
{
    iterator tmp = (*this);

    --(ptr);
    return (tmp);
}

template<typename T, typename A>
typename ft::vector<T, A>::iterator& ft::vector<T, A>::iterator::operator+= (typename ft::vector<T, A>::difference_type n)
{
    ptr += n;
    return (*this);
}

template<typename T, typename A>
typename ft::vector<T, A>::iterator& ft::vector<T, A>::iterator::operator-= (typename ft::vector<T, A>::difference_type n)
{
    ptr -= n;
    return (*this);
}

template<typename T, typename A>
T& ft::vector<T, A>::iterator::operator[] (typename ft::vector<T, A>::difference_type n) const
{
    return (this->ptr[n]);
}

template<typename T, typename A>
typename ft::vector<T, A>::difference_type ft::vector<T, A>::iterator::operator- (const ft::vector<T, A>::iterator& it)
{
    return this->ptr - it.ptr;
}

template<typename T, typename A>
typename ft::vector<T, A>::iterator ft::vector<T, A>::iterator::operator+ (typename ft::vector<T, A>::difference_type n) const
{
    return (iterator(ptr + n));
}

template<typename T, typename A>
typename ft::vector<T, A>::iterator ft::vector<T, A>::iterator::operator- (typename ft::vector<T, A>::difference_type n) const
{
    return (iterator(ptr - n));
}

/***********************************************/
/*               reverse_iterator              */
/***********************************************/

template<typename T, typename A>
ft::vector<T, A>::reverse_iterator::reverse_iterator (){}

template<typename T, typename A>
ft::vector<T, A>::reverse_iterator::reverse_iterator (pointer p): ptr(p){}

template<typename T, typename A>
ft::vector<T, A>::reverse_iterator::reverse_iterator (const reverse_iterator& x):ptr(x.ptr){}

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator& ft::vector<T, A>::reverse_iterator::operator= (const reverse_iterator& x)
{
    this->ptr = x.ptr;
    return (*this);
}

template<typename T, typename A>
bool    ft::vector<T, A>::reverse_iterator::operator== (const reverse_iterator& x) const
{
    if (this->ptr == x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
bool    ft::vector<T, A>::reverse_iterator::operator!= (const reverse_iterator& x) const
{
    if (this->ptr != x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
bool    ft::vector<T, A>::reverse_iterator::operator>= (const reverse_iterator& x) const
{
    if (this->ptr <= x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
bool    ft::vector<T, A>::reverse_iterator::operator<= (const reverse_iterator& x) const
{
    if (this->ptr >= x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
bool    ft::vector<T, A>::reverse_iterator::operator< (const reverse_iterator& x) const
{
    if (this->ptr > x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
bool    ft::vector<T, A>::reverse_iterator::operator> (const reverse_iterator& x) const
{
    if (this->ptr < x.ptr) return (true);
    return (false);
}

template<typename T, typename A>
typename ft::vector<T, A>::reference ft::vector<T, A>::reverse_iterator::operator* () const
{
    return (*ptr);
}

template<typename T, typename A>
typename ft::vector<T, A>::pointer ft::vector<T, A>::reverse_iterator::operator-> () const
{
    return (ptr);
}

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator& ft::vector<T, A>::reverse_iterator::operator++ ()
{
    --ptr;
    return (*this);
}

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator& ft::vector<T, A>::reverse_iterator::operator-- ()
{
    ++ptr;
    return (*this);
}

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator ft::vector<T, A>::reverse_iterator::operator++ (int)
{
    reverse_iterator tmp =(*this);

    --(ptr);
    return (tmp);
}

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator ft::vector<T, A>::reverse_iterator::operator-- (int)
{
    reverse_iterator tmp = (*this);

    ++(ptr);
    return (tmp);
}

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator& ft::vector<T, A>::reverse_iterator::operator+= (typename ft::vector<T, A>::difference_type n)
{
    ptr -= n;
    return (*this);
}

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator& ft::vector<T, A>::reverse_iterator::operator-= (typename ft::vector<T, A>::difference_type n)
{
    ptr += n;
    return (*this);
}

template<typename T, typename A>
T& ft::vector<T, A>::reverse_iterator::operator[] (typename ft::vector<T, A>::difference_type n) const
{
    return (this->ptr[n]);
}

template<typename T, typename A>
typename ft::vector<T, A>::difference_type ft::vector<T, A>::reverse_iterator::operator- (const ft::vector<T, A>::reverse_iterator& it)
{
    return this->ptr + it.ptr;
}

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator ft::vector<T, A>::reverse_iterator::operator+ (typename ft::vector<T, A>::difference_type n) const
{
    return (reverse_iterator(ptr - n));
}

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator ft::vector<T, A>::reverse_iterator::operator- (typename ft::vector<T, A>::difference_type n) const
{
    return (reverse_iterator(ptr + n));
}

/***********************************************/
/*                    begin                    */
/***********************************************/

template<typename T, typename A>
typename ft::vector<T, A>::iterator ft::vector<T, A>::begin()
{
    return (iterator(this->__container));
}

// template<typename T, typename A>
// typename ft::vector<T, A>::const_iterator ft::vector<T, A>::begin() const
// {
//     return (const_iterator(this->__container));
// }

/***********************************************/
/*                     end                     */
/***********************************************/

template<typename T, typename A>
typename ft::vector<T, A>::iterator ft::vector<T, A>::end()
{
    return (iterator(this->__container + __size));
}

// template<typename T, typename A>
// typename ft::vector<T, A>::const_iterator ft::vector<T, A>::end() const
// {
//     return (const_iterator(this->__container + __size));
// }

/***********************************************/
/*                   rbegin                    */
/***********************************************/

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator ft::vector<T, A>::rbegin()
{
    return (reverse_iterator(this->__container + __size - 1));
}

// template<typename T, typename A>
// typename ft::vector<T, A>::const_reverse_iterator ft::vector<T, A>::rbegin() const
// {
//     return (const_reverse_iterator(this->__container + __size - 1));
// }

/***********************************************/
/*                    rend                     */
/***********************************************/

template<typename T, typename A>
typename ft::vector<T, A>::reverse_iterator ft::vector<T, A>::rend()
{
    return (reverse_iterator(this->__container - 1));
}

// template<typename T, typename A>
// typename ft::vector<T, A>::const_reverse_iterator ft::vector<T, A>::rend() const
// {
//     return (const_reverse_iterator(this->__container - 1));
// }
// ! dealocate 