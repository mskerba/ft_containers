#include "vector.hpp"


/***********************************************/
/*                default constructor          */
/***********************************************/


template<class T>
ft::vector<T>::vector (const allocator_type& alloc) :__container(0), __size(0), __capacity(0), __alloc(alloc){}



/***********************************************/
/*                fill constructor             */
/***********************************************/



template<class T>
ft::vector<T>::vector (size_type n, const value_type& val, const allocator_type& alloc): __size(n), __capacity(n), __alloc(alloc)
{
    if (!n)
        return ;
    __container = __alloc.allocate(n);
    for(size_type i = 0; i < __size; i++)
        __alloc.construct(&__container[i], val);
}



/***********************************************/
/*               range constructor             */
/***********************************************/


template<class T>
template <class InputIterator> 
ft::vector<T>::vector (InputIterator first, InputIterator last, const allocator_type& alloc): __size(last - first), __capacity(__size), __alloc(alloc)
{
    if (first > last)
        throw std::invalid_argument("Invalid range passed to vector constructor");
    this->__container = __alloc.allocate(this->__size);
    size_type i = -1;
    while (first != last)
        __alloc.construct(&__container[++i], *(first++));
}


/***********************************************/
/*               copy constructor              */
/***********************************************/


template<class T>
ft::vector<T>::vector(const vector& x): __size(x.__size), __capacity(x.__capacity)
{
    if (!this->__size)
        return ;
    this->__container = __alloc.allocate(this->__size);
    for(size_type i = 0; i < this->__size; i++)
        __alloc.construct(&__container[i], x.__container[i]);
}


/***********************************************/
/*                 destructor                  */
/***********************************************/

template<class T>
ft::vector<T>::~vector()
{
    for (size_type i = this->__size - 1;; i--)
    {
        __alloc.destroy(&this->__container[i]);
        if (!i) break;
    }
}


/***********************************************/
/*                 operator=                   */
/***********************************************/

template<class T>
ft::vector<T>& ft::vector<T>::operator= (const ft::vector<T>& x)
{
    for(size_type i = 0; i < this->__size; i++)
        __alloc.destroy(&__container[i]);
    this->__size = x.__size;
    this->__capacity = x.__capacity;
    this->__container = __alloc.allocate(this->__size);
    for(size_type i = 0; i < this->__size; i++)
        __alloc.construct(&__container[i], x.__container[i]);
    return (*this);
}

/***********************************************/
/*                   size                      */
/***********************************************/

template<class T>
typename ft::vector<T>::size_type ft::vector<T>::size() const
{
    return (this->__size);
}


/***********************************************/
/*                 max_size                    */
/***********************************************/

template<class T>
size_t ft::vector<T>::max_size() const
{
    int sizeT = sizeof(T);
    if (sizeT == 1)
        sizeT = 2;
    return (std::numeric_limits<std::size_t>::max() / sizeT);
}

/***********************************************/
/*                 max_size                    */
/***********************************************/

template<class T>
void ft::vector<T>::resize (size_type n, value_type val)
{
    if (n < this->__size)
    {
        for (size_type i = this->__size -1; i >= n; i--)
            this->__alloc.destroy(&__container[i]);
    }
    else if (n > this->__size)
    {
        pointer newcontainer;
        newcontainer = __alloc.allocate(n);
        for (size_type i = this->__size; i < n; i++)
            __alloc.construct(&newcontainer[i], val);
        for (size_type i = this->__size - 1; i >= 0; i--)
        {
             __alloc.construct(&newcontainer[i], this->__container[i]);
            if (!i) break;
        }
        for (size_type i = this->__size - 1; i >= 0; i--)
        {
             __alloc.destroy(&this->__container[i]);
            if (!i) break;
        }
        __container = newcontainer;
    }
    this->__size = n;
    if (n > this->__capacity && n < 2 * this->__capacity)
        n *= 2;
    this->__capacity = n;
}

/***********************************************/
/*                 capacity                    */
/***********************************************/

template<class T>
size_t ft::vector<T>::capacity () const
{
    return (this->__capacity);
}

/***********************************************/
/*                   empty                     */
/***********************************************/

template<class T>
bool ft::vector<T>::empty() const
{
    if (this->__size)
        return (true);
    return (false);
}

/***********************************************/
/*                 reserve                     */
/***********************************************/

template<class T>
void ft::vector<T>::reserve (size_type n)
{
    if (n <= this->__capacity)
        return ;
    pointer newcontainer;
    newcontainer = __alloc.allocate(n);
    for (size_type i = this->__size - 1;; i--)
    {
        __alloc.construct(&newcontainer[i], this->__container[i]);
        if (!i) break;
    }
    for (size_type i = this->__size - 1;; i--)
    {
        __alloc.destroy(&this->__container[i]);
        if (!i) break;
    }
    __container = newcontainer;
    __capacity = n;
}

/***********************************************/
/*                shrink_to_fit                */
/***********************************************/

template<class T>
void ft::vector<T>::shrink_to_fit()
{
    pointer newcontainer;
    newcontainer = __alloc.allocate(__size);
    for (size_type i = this->__size - 1;; i--)
    {
        __alloc.construct(&newcontainer[i], this->__container[i]);
        if (!i) break;
    }
    for (size_type i = this->__size - 1;; i--)
    {
        __alloc.destroy(&this->__container[i]);
        if (!i) break;
    }
    __container = newcontainer;
    __capacity = __size;
}

/***********************************************/
/*                  operator[]                 */
/***********************************************/

template<class T>
T& ft::vector<T>::operator[] (size_t n)
{
    return (this->__container[n]);
}

template<class T>
const T& ft::vector<T>::operator[] (size_t n) const
{
    return (this->__container[n]);
}

/***********************************************/
/*                      at                     */
/***********************************************/

template<class T>
T& ft::vector<T>::at (size_t n)
{
    return (this->__container[n]);
}

template<class T>
const T& ft::vector<T>::at (size_t n) const
{
    return (this->__container[n]);
}

/***********************************************/
/*                    front                    */
/***********************************************/

template<class T>
T& ft::vector<T>::front()
{
    return (this->__container[0]);
}

template<class T>
const T& ft::vector<T>::front() const
{
    return (this->__container[0]);
}

/***********************************************/
/*                    back                    */
/***********************************************/

template<class T>
T& ft::vector<T>::back()
{
    return (this->__container[__size - 1]);
}

template<class T>
const T& ft::vector<T>::back() const
{
    return (this->__container[__size - 1]);
}

/***********************************************/
/*                    data                     */
/***********************************************/

template<class T>
T* ft::vector<T>::data() throw()
{
    return (__container);
}

template<class T>
const T* ft::vector<T>::data() const throw()
{
    return (__container);
}

/***********************************************/
/*                 assigner                    */
/***********************************************/

template<class T>
template <class InputIterator>
void ft::vector<T>::assign (InputIterator first, InputIterator last)
{
    if (first > last)
        throw std::invalid_argument("Invalid range passed to vector constructor");
    for (size_type i = this->__size - 1;; i--)
    {
        __alloc.destroy(&this->__container[i]);
        if (!i) break;
    }
    this->__size = last - first;
    this->__container = this->__alloc.allocate(this->__size);
    size_type i = -1;
    while (first != last)
        __alloc.construct(&__container[++i], *(first++));
    this->__capacity = this->__size;
}

template<class T>
void ft::vector<T>::assign (size_type n, const value_type& val)
{
    for (size_type i = this->__size - 1;; i--)
    {
        __alloc.destroy(&this->__container[i]);
        if (!i) break;
    }
    this->__container = this->__alloc.allocate(n);
    this->__size = n;
    this->__capacity = n;
    for(size_type i = 0; i < __size; i++)
        __alloc.construct(&__container[i], val);
}

/***********************************************/
/*                  push_back                  */
/***********************************************/

template<class T>
void ft::vector<T>::push_back (const value_type& val)
{
    if (__capacity && __capacity - __size)
    {
        this->__alloc.construct(&__container[size()], val);
        __size++;
        return ;
    }
    __capacity *= 2;
    if (!(__capacity)) __capacity = 1;
    pointer newcontainer;
    newcontainer = __alloc.allocate(__capacity);
    __alloc.construct(&newcontainer[__size], val);
    for (size_type i = this->__size - 1;i > 0; i--)
    {
        __alloc.construct(&newcontainer[i], this->__container[i]);
        if (!i) break;
    }
    for (size_type i = this->__size - 1;; i--)
    {
        __alloc.destroy(&this->__container[i]);
        if (!i) break;
    }
    __size++;
    __container = newcontainer;
}

/***********************************************/
/*                 pop_back                    */
/***********************************************/

template<class T>
void ft::vector<T>::pop_back ()
{
    if (!(__size)) return ;
    this->__size--;
    __alloc.destroy(&__container[__size]);
}

// !/***********************************************/
// !/*                  insert                     */
// !/***********************************************/

// ! template<class T>
// ! iterator ft::vector<T>::insert (iterator position, const value_type& val)
// ! {
// ! 
// ! }
// ! 
// ! template<class T>
// ! void ft::vector<T>::insert (iterator position, size_type n, const value_type& val)
// ! {
// ! 
// ! }
// ! 
// ! template<class T>
// ! template <class InputIterator>
// ! void ft::vector<T>::insert (iterator position, InputIterator first, InputIterator last)
// ! {
// ! 
// ! }

// !/***********************************************/
// !/*                  insert                     */
// !/***********************************************/

// ! template<class T>
// ! iterator ft::vector<T>::erase (iterator position)
// ! {
// ! 
// ! }
// ! 
// ! template<class T>
// ! iterator ft::vector<T>::erase (iterator first, iterator last)
// ! {
// ! 
// ! }

/***********************************************/
/*                   swap                      */
/***********************************************/

template<class T>
void ft::vector<T>::swap (ft::vector<T>& x)
{
    std::swap(this->__container, x.__container);
    std::swap(this->__size, x.__size);
    std::swap(this->__capacity, x.__capacity);
}

/***********************************************/
/*                  clear                     */
/***********************************************/

template<class T>
void ft::vector<T>::clear ()
{
    while (1)
    {
        __alloc.destroy(&this->__container[--(__size)]);
        if (!__size) break;
    }
}

/***********************************************/
/*                get_allocator                */
/***********************************************/

template<class T>
typename ft::vector<T>::allocator_type ft::vector<T>::get_allocator() const
{
    return (this->__alloc);
}

/***********************************************/
/*                  iterator                   */
/***********************************************/

template<typename T>
ft::vector<T>::iterator::iterator (){}

template<typename T>
ft::vector<T>::iterator::iterator (pointer p): ptr(p){}

template<typename T>
ft::vector<T>::iterator::iterator (const iterator& x):ptr(x.ptr){}

template<typename T>
typename ft::vector<T>::iterator& ft::vector<T>::iterator::operator= (const iterator& x)
{
    this->ptr = x.ptr;
    return (*this);
}

template<typename T>
bool    ft::vector<T>::iterator::operator== (const iterator& x) const
{
    if (this->ptr == x.ptr) return (true);
    return (false);
}

template<typename T>
bool    ft::vector<T>::iterator::operator!= (const iterator& x) const
{
    if (this->ptr != x.ptr) return (true);
    return (false);
}

template<typename T>
bool    ft::vector<T>::iterator::operator>= (const iterator& x) const
{
    if (this->ptr >= x.ptr) return (true);
    return (false);
}

template<typename T>
bool    ft::vector<T>::iterator::operator<= (const iterator& x) const
{
    if (this->ptr <= x.ptr) return (true);
    return (false);
}

template<typename T>
bool    ft::vector<T>::iterator::operator< (const iterator& x) const
{
    if (this->ptr < x.ptr) return (true);
    return (false);
}

template<typename T>
bool    ft::vector<T>::iterator::operator> (const iterator& x) const
{
    if (this->ptr > x.ptr) return (true);
    return (false);
}

template<typename T>
typename ft::vector<T>::reference ft::vector<T>::iterator::operator* () const
{
    return (*ptr);
}

template<typename T>
typename ft::vector<T>::pointer ft::vector<T>::iterator::operator-> () const
{
    return (&ptr);
}

template<typename T>
typename ft::vector<T>::iterator& ft::vector<T>::iterator::operator++ ()
{
    ++ptr;
    return (*this);
}

template<typename T>
typename ft::vector<T>::iterator& ft::vector<T>::iterator::operator-- ()
{
    --ptr;
    return (*this);
}

template<typename T>
typename ft::vector<T>::iterator& ft::vector<T>::iterator::operator++ (int)
{
    iterator tmp(*this);

    ++(ptr);
    return (tmp);
}

template<typename T>
typename ft::vector<T>::iterator& ft::vector<T>::iterator::operator-- (int)
{
    iterator tmp(*this);

    --(ptr);
    return (tmp);
}

template<typename T>
typename ft::vector<T>::iterator& ft::vector<T>::iterator::operator+= (typename ft::vector<T>::difference_type n) const
{
    ptr += n;
    return (*this);
}

template<typename T>
typename ft::vector<T>::iterator& ft::vector<T>::iterator::operator-= (typename ft::vector<T>::difference_type n) const
{
    ptr -= n;
    return (*this);
}

template<typename T>
T& ft::vector<T>::iterator::operator[] (typename ft::vector<T>::difference_type n) const
{
    return (ptr + n);
}

template<typename T>
typename ft::vector<T>::iterator operator+ (typename ft::vector<T>::difference_type n, const typename ft::vector<T>::iterator& it)
{
    return (it += n);
}

template<typename T>
typename ft::vector<T>::iterator ft::vector<T>::iterator::operator- (const ft::vector<T>::iterator& it)
{
    return (this->ptr - it.ptr);
}

template<typename T>
typename ft::vector<T>::iterator ft::vector<T>::iterator::operator+ (typename ft::vector<T>::difference_type n)
{
    ptr += n;
    return (*this);
}

template<typename T>
typename ft::vector<T>::iterator ft::vector<T>::iterator::operator- (typename ft::vector<T>::difference_type n)
{
    ptr -= n;
    return (*this);
}

/***********************************************/
/*               reverse_iterator              */
/***********************************************/

template<typename T>
ft::vector<T>::reverse_iterator::reverse_iterator (){}

template<typename T>
ft::vector<T>::reverse_iterator::reverse_iterator (const reverse_iterator& x):ptr(x.ptr){}

template<typename T>
typename ft::vector<T>::reverse_iterator& ft::vector<T>::reverse_iterator::operator= (const reverse_iterator& x)
{
    this->ptr = x.ptr;
    return (*this);
}

template<typename T>
bool    ft::vector<T>::reverse_iterator::operator== (const reverse_iterator& x) const
{
    if (this->ptr == x.ptr) return (true);
    return (false);
}

template<typename T>
bool    ft::vector<T>::reverse_iterator::operator!= (const reverse_iterator& x) const
{
    if (this->ptr != x.ptr) return (true);
    return (false);
}

template<typename T>
bool    ft::vector<T>::reverse_iterator::operator>= (const reverse_iterator& x) const
{
    if (this->ptr >= x.ptr) return (true);
    return (false);
}

template<typename T>
bool    ft::vector<T>::reverse_iterator::operator<= (const reverse_iterator& x) const
{
    if (this->ptr <= x.ptr) return (true);
    return (false);
}

template<typename T>
bool    ft::vector<T>::reverse_iterator::operator< (const reverse_iterator& x) const
{
    if (this->ptr < x.ptr) return (true);
    return (false);
}

template<typename T>
bool    ft::vector<T>::reverse_iterator::operator> (const reverse_iterator& x) const
{
    if (this->ptr > x.ptr) return (true);
    return (false);
}

template<typename T>
typename ft::vector<T>::reference ft::vector<T>::reverse_iterator::operator* () const
{
    return (*ptr);
}

template<typename T>
typename ft::vector<T>::pointer ft::vector<T>::reverse_iterator::operator-> () const
{
    return (&ptr);
}

template<typename T>
typename ft::vector<T>::reverse_iterator& ft::vector<T>::reverse_iterator::operator++ ()
{
    --ptr;
    return (*this);
}

template<typename T>
typename ft::vector<T>::reverse_iterator& ft::vector<T>::reverse_iterator::operator-- ()
{
    ++ptr;
    return (*this);
}

template<typename T>
typename ft::vector<T>::reverse_iterator& ft::vector<T>::reverse_iterator::operator++ (int)
{
    reverse_iterator tmp(*this);

    --(ptr);
    return (tmp);
}

template<typename T>
typename ft::vector<T>::reverse_iterator& ft::vector<T>::reverse_iterator::operator-- (int)
{
    reverse_iterator tmp(*this);

    ++(ptr);
    return (tmp);
}

template<typename T>
typename ft::vector<T>::reverse_iterator& ft::vector<T>::reverse_iterator::operator+= (typename ft::vector<T>::difference_type n) const
{
    ptr -= n;
    return (*this);
}

template<typename T>
typename ft::vector<T>::reverse_iterator& ft::vector<T>::reverse_iterator::operator-= (typename ft::vector<T>::difference_type n) const
{
    ptr -= n;
    return (*this);
}

template<typename T>
T& ft::vector<T>::reverse_iterator::operator[] (typename ft::vector<T>::difference_type n) const
{
    return (ptr - n);
}

template<typename T>
typename ft::vector<T>::reverse_iterator operator+ (typename ft::vector<T>::difference_type n, const typename ft::vector<T>::reverse_iterator& it)
{
    return (it -= n);
}

template<typename T>
typename ft::vector<T>::reverse_iterator ft::vector<T>::reverse_iterator::operator- (const ft::vector<T>::reverse_iterator& it)
{
    return (this->ptr - it.ptr);
}

template<typename T>
typename ft::vector<T>::reverse_iterator ft::vector<T>::reverse_iterator::operator+ (typename ft::vector<T>::difference_type n)
{
    ptr -= n;
    return (*this);
}

template<typename T>
typename ft::vector<T>::reverse_iterator ft::vector<T>::reverse_iterator::operator- (typename ft::vector<T>::difference_type n)
{
    ptr += n;
    return (*this);
}

/***********************************************/
/*                    begin                    */
/***********************************************/

template<typename T>
typename ft::vector<T>::iterator ft::vector<T>::begin()
{

}

template<typename T>
typename ft::vector<T>::const_iterator ft::vector<T>::begin() const
{

}


/***********************************************/
/*                     end                     */
/***********************************************/

template<typename T>
typename ft::vector<T>::iterator ft::vector<T>::end()
{

}

template<typename T>
typename ft::vector<T>::const_iterator ft::vector<T>::end() const
{

}

/***********************************************/
/*                   rbegin                    */
/***********************************************/

template<typename T>
typename ft::vector<T>::reverse_iterator ft::vector<T>::rbegin()
{

}

template<typename T>
typename ft::vector<T>::const_reverse_iterator ft::vector<T>::rbegin() const
{

}

/***********************************************/
/*                    rend                     */
/***********************************************/

template<typename T>
typename ft::vector<T>::reverse_iterator ft::vector<T>::rend()
{

}




// ! dealocate 